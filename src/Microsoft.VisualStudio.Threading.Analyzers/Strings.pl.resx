<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Zamiast tego oczekuj na {0}</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Zamiast tego używaj oczekiwania</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Synchroniczne oczekiwanie na zadania lub elementy typu awaiter mogą powodować zakleszczenia. Zamiast tego używaj metody await lub JoinableTaskFactory.Run.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Unikaj problematycznych oczekiwań synchronicznych</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>Usługa programu Visual Studio „{0}” powinna być używana w wątku głównym w sposób jawny.
Najpierw wywołaj metodę ThreadHelper.ThrowIfNotOnUIThread() lub oczekuj na metodę JoinableTaskFactory.SwitchToMainThreadAsync().</value>
    <comment>{0} is a type name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Używaj usług programu VS z wątku interfejsu użytkownika</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Unikaj metod „async void”, ponieważ wszelkie wyjątki, które nie zostaną przez nie obsłużone, spowodują awarię procesu.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Unikaj metod „async void”</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Unikaj używania asynchronicznego wyrażenia lambda dla typu delegata zwracającego „void”, ponieważ wszelkie wyjątki, które nie zostaną obsłużone przez delegata, spowodują awarię procesu.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Unikaj nieobsługiwanych delegatów asynchronicznych</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>Delegatów AsyncEventHandler powinno się wywoływać za pośrednictwem metody rozszerzenia „TplExtensions.InvokeAsync()” zdefiniowanej w zestawie Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Zdarzenia asynchroniczne wywołuj za pomocą metody InvokeAsync</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>Wywołanie oczekiwania dla obiektu Task wewnątrz metody JoinableTaskFactory.Run, gdy dane zadanie zainicjowano poza delegatem, może spowodować zakleszczenia.
Tego problemu można uniknąć, zapewniając, że zadanie zostanie zainicjowane wewnątrz delegata lub za pomocą klasy JoinableTask (a nie klasy Task).</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Unikaj oczekiwania na zadania bez możliwości dołączenia w kontekstach dołączania</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Element Lazy&lt;Task&lt;T&gt;&gt;.Value może ulec zakleszczeniu.
Zamiast tego używaj klasy AsyncLazy&lt;T&gt;.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Unikaj używania klasy Lazy&lt;T&gt;, jeśli T jest obiektem Task&lt;T2&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>Metoda {0} powoduje blokowanie synchroniczne. Zamiast tego oczekuj na {1}.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>Metoda {0} powoduje blokowanie synchroniczne. Zamiast tego używaj oczekiwania.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>W metodach asynchronicznych wywołuj metody asynchroniczne</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Ogranicz stosowanie wywołań metod z blokowaniem synchronicznym, takich jak JoinableTaskFactory.Run lub Task.Result, do publicznych elementów członkowskich punktów wyjścia, w przypadku których konieczne jest działanie synchroniczne. Stosowanie tego rozwiązania w przypadku wewnętrznych elementów członkowskich może powodować niepotrzebne dodawanie ramek synchronicznych między ramkami asynchronicznymi, co może prowadzić do wyczerpania puli wątków.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Logikę wewnętrzną implementuj asynchronicznie</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Zmień nazwę na: {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>W nazwach metod zwracających obiekty Task używaj sufiksu „Async”.</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>W przypadku metod asynchronicznych używaj sufiksu „Async”</value>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Unikaj przeciążeń metod zakładających korzystanie z właściwości TaskScheduler.Current. Używaj przeciążenia przyjmującego obiekt TaskScheduler i jawnie określaj właściwość TaskScheduler.Default (lub inną).</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Unikaj przeciążeń metod zakładających korzystanie z właściwości TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Zmień zwracany typ na Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Podaj wystąpienie elementu JoinableTaskFactory w tym wywołaniu (albo innym przeciążeniu), aby uniknąć zakleszczeń w wątku głównym.</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>Podaj element JoinableTaskFactory w miejscach, gdzie jest to dopuszczalne</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Uwidocznij asynchroniczną wersję tej metody, która nie powoduje synchronicznego blokowania. Następnie uprość tę metodę, aby wywołać tę metodę asynchroniczną w ramach delegata JoinableTaskFactory.Run.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Oferuj metody asynchroniczne</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Zaczekaj, aż metoda JoinableTaskFactory.SwitchToMainThreadAsync() przełączy się do wątku interfejsu użytkownika zamiast interfejsów API, które mogą ulec zakleszczeniu lub wymagać określenia priorytetu.</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Unikaj starszych interfejsów API przełączających wątki</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Brak operatora await dla wyrażenia „using”.</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Oczekuj na zadanie wewnątrz wyrażenia using</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Oczekuj w wyrażeniu using</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>Zamiast tego używaj oczekiwania</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
</root>