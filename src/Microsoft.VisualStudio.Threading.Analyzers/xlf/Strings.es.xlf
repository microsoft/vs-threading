<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="es" original="../Strings.resx">
    <body>
      <trans-unit id="AwaitXInstead" translate="yes" xml:space="preserve">
        <source>Await {0} instead</source>
        <target state="translated">Use await {0} en su lugar</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.
{0} is a method name.</note>
      </trans-unit>
      <trans-unit id="SystemIAsyncDisposablePackageNote">
        <source>The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package.</source>
        <target state="new">The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseAwaitInstead" translate="yes" xml:space="preserve">
        <source>Use await instead</source>
        <target state="translated">Use await en su lugar</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD001_MessageFormat" translate="yes" xml:space="preserve">
        <source>Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority.</source>
        <target state="translated">Use el método await JoinableTaskFactory.SwitchToMainThreadAsync() para cambiar al subproceso de interfaz de usuario en lugar de a API que pueden causar interbloqueo o requerir que se especifique una prioridad.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD001_Title" translate="yes" xml:space="preserve">
        <source>Avoid legacy thread switching APIs</source>
        <target state="translated">Evite cambiar a API de subprocesos heredados</target>
        <note from="MultilingualBuild" annotates="source" priority="2">thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</note>
      </trans-unit>
      <trans-unit id="VSTHRD002_CodeFix_Await_Title" translate="yes" xml:space="preserve">
        <source>Use await instead</source>
        <target state="translated">Use await en su lugar</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD002_MessageFormat" translate="yes" xml:space="preserve">
        <source>Synchronously waiting on tasks or awaiters may cause deadlocks. Use await or JoinableTaskFactory.Run instead.</source>
        <target state="translated">La espera sincrónica de tareas o elementos que ejecutan await puede provocar interbloqueos. Use await o JoinableTaskFactory.Run en su lugar.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD002_Title" translate="yes" xml:space="preserve">
        <source>Avoid problematic synchronous waits</source>
        <target state="translated">Evite esperas sincrónicas problemáticas</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD003_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid awaiting or returning a Task representing work that was not started within your context as that can lead to deadlocks.
Start the work within this context, or use JoinableTaskFactory.RunAsync to start the task and await the returned JoinableTask instead.</source>
        <target state="translated">Evita la espera o la devolución de una tarea que representa el trabajo no iniciado en su contexto, ya que puede dar lugar a bloqueos.
Inicie el trabajo en este contexto o use JoinableTaskFactory.RunAsync para iniciar la tarea y esperar en su lugar el objeto JoinableTask devuelto.</target>
        <note from="MultilingualUpdate" annotates="source" priority="2" />
      </trans-unit>
      <trans-unit id="VSTHRD003_Title" translate="yes" xml:space="preserve">
        <source>Avoid awaiting foreign Tasks</source>
        <target state="translated">Evitar la espera de tareas externas</target>
        <note from="MultilingualUpdate" annotates="source" priority="2" />
      </trans-unit>
      <trans-unit id="VSTHRD004_MessageFormat" translate="yes" xml:space="preserve">
        <source>Calls to JoinableTaskFactory.SwitchToMainThreadAsync() must be awaited.</source>
        <target state="translated">Se deben esperar las llamadas a JoinableTaskFactory.SwitchToMainThreadAsync().</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD004_Title" translate="yes" xml:space="preserve">
        <source>Await SwitchToMainThreadAsync</source>
        <target state="translated">Esperar a SwitchToMainThreadAsync</target>
        <note from="MultilingualBuild" annotates="source" priority="2">Do not translate either of these. The first is a keyword, the second is a method name.</note>
      </trans-unit>
      <trans-unit id="VSTHRD010_MessageFormat_Async" translate="yes" xml:space="preserve">
        <source>Accessing "{0}" should only be done on the main thread. Await JoinableTaskFactory.SwitchToMainThreadAsync() first.</source>
        <target state="translated">El acceso a "{0}" solo se debe realizar en el subproceso principal. Espere primero a JoinableTaskFactory.SwitchToMainThreadAsync().</target>
        <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name.</note>
      </trans-unit>
      <trans-unit id="VSTHRD010_MessageFormat_Sync" translate="yes" xml:space="preserve">
        <source>Accessing "{0}" should only be done on the main thread. Call {1}() first.</source>
        <target state="translated">El acceso a "{0}" solo se debe realizar en el subproceso principal. Llame primero a {1}().</target>
        <note from="MultilingualBuild" annotates="source" priority="2">{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</note>
      </trans-unit>
      <trans-unit id="VSTHRD010_Title" translate="yes" xml:space="preserve">
        <source>Invoke single-threaded types on Main thread</source>
        <target state="translated">Invocar tipos uniproceso en el subproceso principal</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD011_MessageFormat" translate="yes" xml:space="preserve">
        <source>Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
        <target state="translated">Lazy&lt;Task&lt;T&gt;&gt;. Posible interbloqueo del valor.
Use AsyncLazy&lt;T&gt; en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD011_Title" translate="yes" xml:space="preserve">
        <source>Use AsyncLazy&lt;T&gt;</source>
        <target state="translated">Usar AsyncLazy&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD011b_MessageFormat" translate="yes" xml:space="preserve">
        <source>Invoking or blocking on async code in a Lazy&lt;T&gt; value factory can deadlock.
Use AsyncLazy&lt;T&gt; instead.</source>
        <target state="translated">La invocación o el bloqueo del código asincrónico en un valor Lazy&lt;T&gt; predeterminado de fábrica puede generar un interbloqueo.
Use AsyncLazy&lt;T&gt; en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD012_MessageFormat" translate="yes" xml:space="preserve">
        <source>Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread.</source>
        <target state="translated">Proporcione una instancia de JoinableTaskFactory en esta llamada (u otra sobrecarga) para evitar interbloqueos con el subproceso principal.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD012_Title" translate="yes" xml:space="preserve">
        <source>Provide JoinableTaskFactory where allowed</source>
        <target state="translated">Proporcione JoinableTaskFactory donde se permita</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD100_CodeFix_Title" translate="yes" xml:space="preserve">
        <source>Change return type to Task</source>
        <target state="translated">Cambie el tipo de valor devuelto a Task</target>
        <note from="MultilingualBuild" annotates="source" priority="2">Task is a type name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD100_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid "async void" methods, because any exceptions not handled by the method will crash the process.</source>
        <target state="translated">Evite métodos "async void", porque las excepciones no controladas por el método bloquearán el proceso.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
      </trans-unit>
      <trans-unit id="VSTHRD100_Title" translate="yes" xml:space="preserve">
        <source>Avoid async void methods</source>
        <target state="translated">Evite métodos async void</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"async void" is a pair of C# keywords. Do not translate them.</note>
      </trans-unit>
      <trans-unit id="VSTHRD101_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid using async lambda for a void returning delegate type, because any exceptions not handled by the delegate will crash the process.</source>
        <target state="translated">Evite usar la lambda async para un tipo de delegado de devolución void, porque las excepciones no controladas por el delegado bloquearán el proceso.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"void" is a C# keyword and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD101_Title" translate="yes" xml:space="preserve">
        <source>Avoid unsupported async delegates</source>
        <target state="translated">Evite delegados asincrónicos no compatibles</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD102_MessageFormat" translate="yes" xml:space="preserve">
        <source>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</source>
        <target state="translated">Limite el uso de llamadas de métodos de bloqueo sincrónico, como JoinableTaskFactory.Run o Task.Result, a miembros de punto de entrada públicos donde tiene que ser sincrónico. El uso para miembros internos puede agregar innecesariamente marcos sincrónicos entre marcos asincrónicos, provocando el agotamiento del conjunto de subprocesos.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD102_Title" translate="yes" xml:space="preserve">
        <source>Implement internal logic asynchronously</source>
        <target state="translated">Implemente la lógica interna asincrónicamente</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD103_MessageFormat" translate="yes" xml:space="preserve">
        <source>{0} synchronously blocks. Await {1} instead.</source>
        <target state="translated">{0} bloquea sincrónicamente. Use await {1} en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD103_MessageFormat_UseAwaitInstead" translate="yes" xml:space="preserve">
        <source>{0} synchronously blocks. Use await instead.</source>
        <target state="translated">{0} bloquea sincrónicamente. Use await en su lugar.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD103_Title" translate="yes" xml:space="preserve">
        <source>Call async methods when in an async method</source>
        <target state="translated">Llame a métodos asincrónicos cuando esté en un método asincrónico</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD104_MessageFormat" translate="yes" xml:space="preserve">
        <source>Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</source>
        <target state="translated">Exponga una versión asincrónica de este método que no cause bloqueo de manera sincrónica. A continuación, simplifique este método para llamar a ese método asincrónico dentro de un delegado JoinableTaskFactory.Run.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD104_Title" translate="yes" xml:space="preserve">
        <source>Offer async methods</source>
        <target state="translated">Ofrezca métodos asincrónicos</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD105_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</source>
        <target state="translated">Evite las sobrecargas de métodos que asumen TaskScheduler.Current. Use una sobrecarga que acepte un elemento TaskScheduler y especifique TaskScheduler.Default (o cualquier otro) explícitamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD105_Title" translate="yes" xml:space="preserve">
        <source>Avoid method overloads that assume TaskScheduler.Current</source>
        <target state="translated">Evite las sobrecargas de métodos que asumen TaskScheduler.Current</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD106_MessageFormat" translate="yes" xml:space="preserve">
        <source>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly.</source>
        <target state="translated">Los delegados de AsyncEventHandler deben invocarse a través del método de extensión "TplExtensions.InvokeAsync()" definido en el ensamblado Microsoft.VisualStudio.Threading.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD106_Title" translate="yes" xml:space="preserve">
        <source>Use InvokeAsync to raise async events</source>
        <target state="translated">Use InvokeAsync para desencadenar eventos asincrónicos</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD107_CodeFix_Title" translate="yes" xml:space="preserve">
        <source>Await using expression</source>
        <target state="translated">Usar await en expresión using</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD107_MessageFormat" translate="yes" xml:space="preserve">
        <source>Missing await operator for "using" expression.</source>
        <target state="translated">Falta el operador await en la expresión "using".</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await" and "using" are C# keywords and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD107_Title" translate="yes" xml:space="preserve">
        <source>Await Task within using expression</source>
        <target state="translated">Usar await para tarea dentro de expresión using</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD108_MessageFormat" translate="yes" xml:space="preserve">
        <source>Thread affinity checks should be unconditional.</source>
        <target state="translated">Las comprobaciones de afinidad de subproceso deben ser incondicionales.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD108_Title" translate="yes" xml:space="preserve">
        <source>Assert thread affinity unconditionally</source>
        <target state="translated">Declarar afinidad de subproceso incondicionalmente</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD109_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid throwing when not on the main thread while in an async or Task-returning method. Switch to the thread required instead.</source>
        <target state="translated">Evite lanzar cuando no esté en el subproceso principal durante un método asincrónico o que devuelve tareas. Cambie en su lugar al subproceso requerido.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD109_Title" translate="yes" xml:space="preserve">
        <source>Switch instead of assert in async methods</source>
        <target state="translated">Cambiar en lugar de declarar en métodos asincrónicos</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD110_MessageFormat" translate="yes" xml:space="preserve">
        <source>Observe the awaitable result of this method call by awaiting it, assigning to a variable, or passing it to another method.</source>
        <target state="translated">Observe el resultado que se puede esperar de esta llamada a método cuando se espera, se asigna a una variable o se pasa a otro método.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD110_Title" translate="yes" xml:space="preserve">
        <source>Observe result of async calls</source>
        <target state="translated">Observar resultado de llamadas asincrónicas</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD111_CodeFix_False_Title" translate="yes" xml:space="preserve">
        <source>Add .ConfigureAwait(false)</source>
        <target state="translated">Agregar .ConfigureAwait(false)</target>
        <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(false)" should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD111_CodeFix_True_Title" translate="yes" xml:space="preserve">
        <source>Add .ConfigureAwait(true)</source>
        <target state="translated">Agregar .ConfigureAwait(true)</target>
        <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(true)" should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD111_MessageFormat" translate="yes" xml:space="preserve">
        <source>Add .ConfigureAwait(bool) to your await expression.</source>
        <target state="translated">Agregue .ConfigureAwait(bool) a su expresión await.</target>
        <note from="MultilingualBuild" annotates="source" priority="2">".ConfigureAwait(bool)" and "await" should NOT be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD111_Title" translate="yes" xml:space="preserve">
        <source>Use ConfigureAwait(bool)</source>
        <target state="translated">Usar ConfigureAwait(bool)</target>
        <note from="MultilingualBuild" annotates="source" priority="2">"ConfigureAwait(bool)" is a reference and should NOT be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD112_CodeFix_Title">
        <source>Add implementation of System.IAsyncDisposable.</source>
        <target state="new">Add implementation of System.IAsyncDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD112_MessageFormat">
        <source>Implement the System.IAsyncDisposable interface when implementing the obsolete Microsoft.VisualStudio.Threading.IAsyncDisposable interface.</source>
        <target state="new">Implement the System.IAsyncDisposable interface when implementing the obsolete Microsoft.VisualStudio.Threading.IAsyncDisposable interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD112_Title">
        <source>Implement System.IAsyncDisposable</source>
        <target state="new">Implement System.IAsyncDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD113_MessageFormat">
        <source>Add a check for System.IAsyncDisposable in the same code block that checks for Microsoft.VisualStudio.Threading.IAsyncDisposable that behaves similarly.</source>
        <target state="new">Add a check for System.IAsyncDisposable in the same code block that checks for Microsoft.VisualStudio.Threading.IAsyncDisposable that behaves similarly.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD113_Title">
        <source>Check for System.IAsyncDisposable</source>
        <target state="new">Check for System.IAsyncDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD200_AddAsync_MessageFormat" translate="yes" xml:space="preserve">
        <source>Use "Async" suffix in names of methods that return an awaitable type.</source>
        <target state="translated">Use el sufijo "Async" en nombres de métodos que devuelven un tipo que admite await.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD200_CodeFix_Title" translate="yes" xml:space="preserve">
        <source>Rename to {0}</source>
        <target state="translated">Cambie el nombre a {0}</target>
        <note from="MultilingualBuild" annotates="source" priority="2">{0} is a method name.</note>
      </trans-unit>
      <trans-unit id="VSTHRD200_RemoveAsync_MessageFormat" translate="yes" xml:space="preserve">
        <source>Avoid "Async" suffix in names of methods that do not return an awaitable type.</source>
        <target state="translated">Evite el sufijo "Async" en nombres de métodos que no devuelven un tipo que admite await.</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD200_Title" translate="yes" xml:space="preserve">
        <source>Use "Async" suffix for async methods</source>
        <target state="translated">Use el sufijo "Async" para métodos asincrónicos</target>
        <note />
      </trans-unit>
      <trans-unit id="VSTHRD201_CodeFix_Title">
        <source>Call ThrowIfCancellationRequested()</source>
        <target state="translated">Llamar a ThrowIfCancellationRequested()</target>
        <note>"ThrowIfCancellationRequested" is a method name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD201_MessageFormat">
        <source>Check for cancellation after calling SwitchToMainThreadAsync(CancellationToken).</source>
        <target state="translated">Compruebe la cancelación después de llamar a SwitchToMainThreadAsync(CancellationToken).</target>
        <note>"SwitchToMainThreadAsync" is a method name and should not be translated.</note>
      </trans-unit>
      <trans-unit id="VSTHRD201_Title">
        <source>Check cancellation after SwitchToMainThreadAsync</source>
        <target state="translated">Comprobar cancelación después de SwitchToMainThreadAsync</target>
        <note>"SwitchToMainThreadAsync" is a method name and should not be translated.</note>
      </trans-unit>
    </body>
  </file>
</xliff>