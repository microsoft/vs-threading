<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>代わりに {0} を待機する</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>代わりに Await を使用する</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>同期的にタスクまたは awaiter を待機すると、デッドロックが引き起こされる可能性があります。代わりに await または JoinableTaskFactory.Run を使用してください。</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>問題のある同期待機を避ける</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>Visual Studio サービス "{0}" は、明示的にメイン スレッドで使用する必要があります。
ThreadHelper.ThrowIfNotOnUIThread() を呼び出すか、まず JoinableTaskFactory.SwitchToMainThreadAsync() を待機してください。</value>
    <comment>{0} is a type name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>UI スレッドから VS サービスを使用する</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>"async void" メソッドは使用しないでください。このメソッドで処理されていない例外によりプロセスがクラッシュします。</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>async void メソッドを使用しない</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>デリゲート型を返す void に非同期ラムダは使用しないでください。このデリゲートで処理されていない例外によりプロセスがクラッシュします。</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>サポートされていないい非同期デリゲートを使用しない</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>AsyncEventHandler デリゲートは、Microsoft.VisualStudio.Threading アセンブリで定義されている拡張メソッド "TplExtensions.InvokeAsync()" で呼び出される必要があります。</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>InvokeAsync を使用して非同期イベントを発生させる</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>タスクがデリゲート外部で初期化されている場合、JoinableTaskFactory.Run 内の Task で await を呼び出すと、デッドロックが引き起こされる可能性があります。
この問題は、タスクが確実にデリゲート内で初期化されるようにするか、Task の代わりに JoinableTask を使用することによって回避できます。</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>結合コンテキストで結合できないタスクを待機しない</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value はデッドロックを引き起こす可能性があります。
代わりに AsyncLazy&lt;T&gt; を使用してください。</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>T が Task&lt;T2&gt; を表す Lazy&lt;T&gt; を使用しない</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} は同期的にブロックを実行します。代わりに {1} を待機してください。</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} は同期的にブロックを実行します。代わりに await を使用してください。</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>非同期メソッドの場合に非同期メソッドを呼び出す</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>JoinableTaskFactory.Run または Task.Result など、同期的にブロックを行うメソッド呼び出しの使用は、同期が必要な公開エントリポイント メンバーに限定してください。内部メンバーに対して使用すると、非同期フレーム間に同期フレームが不必要に追加され、スレッドプールが消費されます。</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>内部論理を非同期的に実装する</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>{0} に名前を変更する</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>タスクを返すメソッドの名前に "Async" サフィックスを使用します。</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>非同期メソッドに "Async" サフィックスを使用する</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>戻り値の型を Task に変更する</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>TaskScheduler.Current を仮定するメソッド オーバーロードを使用しないでください。TaskScheduler を受け入れるオーバーロードを使用し、TaskScheduler.Default (または他のプロパティ) を明示的に指定します。</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>TaskScheduler.Current を仮定するメソッド オーバーロードを使用しない</value>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>この呼び出し (または別のオーバーロード) で JoinableTaskFactory のインスタンスを提供して、メイン スレッドとのデッドロックを回避します。</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>許可されている場合は JoinableTaskFactory を提供する</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>このメソッドの、同期的にブロックしない非同期バージョンを公開してください。次に、このメソッドを単純化し、JoinableTaskFactory.Run デリゲート内でその非同期メソッドを呼び出すようにします。</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>非同期メソッドを提供する</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>UI スレッドに切り替えるためには、デッドロックを引き起こす可能性や、優先順位の指定の必要がある API を使用するのではなく、JoinableTaskFactory.SwitchToMainThreadAsync() を待機してください。</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>従来のスレッド切り替え API を使用しない</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>"using" 式に await 演算子がありません。</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>using 式内の Task を待機する</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>using 式を待機する</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>代わりに Await を使用する</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
</root>