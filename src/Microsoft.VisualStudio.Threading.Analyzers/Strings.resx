<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Await {0} instead</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Use await instead</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Synchronously waiting on tasks or awaiters may cause deadlocks. Use await or JoinableTaskFactory.Run instead.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Avoid problematic synchronous waits</value>
  </data>
  <data name="VSTHRD010_MessageFormat_Sync" xml:space="preserve">
    <value>Accessing "{0}" should only be done on the main thread. Call {1}() first.</value>
    <comment>{0} is a type or member name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Invoke single-threaded types on Main thread</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Change return type to Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Avoid "async void" methods, because any exceptions not handled by the method will crash the process</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Avoid async void methods</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>Avoid using async lambda for a void returning delegate type, because any exceptions not handled by the delegate will crash the process</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Avoid unsupported async delegates</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>AsyncEventHandler delegates should be invoked via the extension method "TplExtensions.InvokeAsync()" defined in Microsoft.VisualStudio.Threading assembly</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Use InvokeAsync to raise async events</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>Avoid awaiting or returning a Task representing work that was not started within your context as that can lead to deadlocks.
Start the work within this context, or use JoinableTaskFactory.RunAsync to start the task and await the returned JoinableTask instead.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Avoid awaiting foreign Tasks</value>
  </data>
  <data name="VSTHRD011b_MessageFormat" xml:space="preserve">
    <value>Invoking or blocking on async code in a Lazy&lt;T&gt; value factory can deadlock. Use AsyncLazy&lt;T&gt; instead.</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value can deadlock. Use AsyncLazy&lt;T&gt; instead.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Use AsyncLazy&lt;T&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} synchronously blocks. Await {1} instead.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} synchronously blocks. Use await instead.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Call async methods when in an async method</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Limit use of synchronously blocking method calls such as JoinableTaskFactory.Run or Task.Result to public entrypoint members where you must be synchronous. Using it for internal members can needlessly add synchronous frames between asynchronous frames, leading to threadpool exhaustion.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Implement internal logic asynchronously</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Rename to {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_AddAsync_MessageFormat" xml:space="preserve">
    <value>Use "Async" suffix in names of methods that return an awaitable type</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Use "Async" suffix for async methods</value>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Avoid method overloads that assume TaskScheduler.Current. Use an overload that accepts a TaskScheduler and specify TaskScheduler.Default (or any other) explicitly.</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Avoid method overloads that assume TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Provide an instance of JoinableTaskFactory in this call (or another overload) to avoid deadlocks with the main thread</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>Provide JoinableTaskFactory where allowed</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Expose an async version of this method that does not synchronously block. Then simplify this method to call that async method within a JoinableTaskFactory.Run delegate.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Offer async methods</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Await JoinableTaskFactory.SwitchToMainThreadAsync() to switch to the UI thread instead of APIs that can deadlock or require specifying a priority</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Avoid legacy thread switching APIs</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Missing await operator for "using" expression</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Await Task within using expression</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Await using expression</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>Use await instead</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD108_MessageFormat" xml:space="preserve">
    <value>Thread affinity checks should be unconditional</value>
  </data>
  <data name="VSTHRD108_Title" xml:space="preserve">
    <value>Assert thread affinity unconditionally</value>
  </data>
  <data name="VSTHRD010_MessageFormat_Async" xml:space="preserve">
    <value>Accessing "{0}" should only be done on the main thread. Await JoinableTaskFactory.SwitchToMainThreadAsync() first.</value>
    <comment>{0} is a type or member name.</comment>
  </data>
  <data name="VSTHRD109_MessageFormat" xml:space="preserve">
    <value>Avoid throwing when not on the main thread while in an async or Task-returning method. Switch to the thread required instead.</value>
  </data>
  <data name="VSTHRD109_Title" xml:space="preserve">
    <value>Switch instead of assert in async methods</value>
  </data>
  <data name="VSTHRD004_MessageFormat" xml:space="preserve">
    <value>Calls to JoinableTaskFactory.SwitchToMainThreadAsync() must be awaited</value>
  </data>
  <data name="VSTHRD004_Title" xml:space="preserve">
    <value>Await SwitchToMainThreadAsync</value>
    <comment>Do not translate either of these. The first is a keyword, the second is a method name.</comment>
  </data>
  <data name="VSTHRD110_MessageFormat" xml:space="preserve">
    <value>Observe the awaitable result of this method call by awaiting it, assigning to a variable, or passing it to another method</value>
  </data>
  <data name="VSTHRD110_Title" xml:space="preserve">
    <value>Observe result of async calls</value>
  </data>
  <data name="VSTHRD200_RemoveAsync_MessageFormat" xml:space="preserve">
    <value>Avoid "Async" suffix in names of methods that do not return an awaitable type</value>
  </data>
  <data name="VSTHRD111_CodeFix_False_Title" xml:space="preserve">
    <value>Add .ConfigureAwait(false)</value>
    <comment>".ConfigureAwait(false)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_CodeFix_True_Title" xml:space="preserve">
    <value>Add .ConfigureAwait(true)</value>
    <comment>".ConfigureAwait(true)" should not be translated.</comment>
  </data>
  <data name="VSTHRD111_MessageFormat" xml:space="preserve">
    <value>Add .ConfigureAwait(bool) to your await expression</value>
    <comment>".ConfigureAwait(bool)" and "await" should NOT be translated.</comment>
  </data>
  <data name="VSTHRD111_Title" xml:space="preserve">
    <value>Use ConfigureAwait(bool)</value>
    <comment>"ConfigureAwait(bool)" is a reference and should NOT be translated.</comment>
  </data>
  <data name="VSTHRD201_MessageFormat" xml:space="preserve">
    <value>Check for cancellation after calling SwitchToMainThreadAsync(CancellationToken).</value>
    <comment>"SwitchToMainThreadAsync" is a method name and should not be translated.</comment>
  </data>
  <data name="VSTHRD201_Title" xml:space="preserve">
    <value>Check cancellation after SwitchToMainThreadAsync</value>
    <comment>"SwitchToMainThreadAsync" is a method name and should not be translated.</comment>
  </data>
  <data name="VSTHRD201_CodeFix_Title" xml:space="preserve">
    <value>Call ThrowIfCancellationRequested()</value>
    <comment>"ThrowIfCancellationRequested" is a method name and should not be translated.</comment>
  </data>
  <data name="VSTHRD112_CodeFix_Title" xml:space="preserve">
    <value>Add implementation of System.IAsyncDisposable.</value>
  </data>
  <data name="VSTHRD112_MessageFormat" xml:space="preserve">
    <value>Implement the System.IAsyncDisposable interface when implementing the obsolete Microsoft.VisualStudio.Threading.IAsyncDisposable interface</value>
  </data>
  <data name="VSTHRD112_Title" xml:space="preserve">
    <value>Implement System.IAsyncDisposable</value>
  </data>
  <data name="VSTHRD113_MessageFormat" xml:space="preserve">
    <value>Add a check for System.IAsyncDisposable in the same code block that checks for Microsoft.VisualStudio.Threading.IAsyncDisposable that behaves similarly</value>
  </data>
  <data name="VSTHRD113_Title" xml:space="preserve">
    <value>Check for System.IAsyncDisposable</value>
  </data>
  <data name="SystemIAsyncDisposablePackageNote" xml:space="preserve">
    <value>The System.IAsyncDisposable interface is defined in the Microsoft.Bcl.AsyncInterfaces NuGet package.</value>
  </data>
  <data name="VSTHRD114_MessageFormat" xml:space="preserve">
    <value>Avoid returning null from a Task-returning method</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD114_Title" xml:space="preserve">
    <value>Avoid returning a null Task</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD114_CodeFix_CompletedTask" xml:space="preserve">
    <value>Use 'Task.CompletedTask' instead</value>
    <comment>"Task.CompletedTask" should not be translated.</comment>
  </data>
  <data name="VSTHRD114_CodeFix_FromResult" xml:space="preserve">
    <value>Use 'Task.FromResult' instead</value>
    <comment>"Task.FromResult" should not be translated.</comment>
  </data>
</root>