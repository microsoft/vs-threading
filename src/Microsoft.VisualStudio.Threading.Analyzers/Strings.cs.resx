<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AwaitXInstead" xml:space="preserve">
    <value>Použijte raději await {0}.</value>
    <comment>"await" is a C# keyword and should not be translated.
{0} is a method name.</comment>
  </data>
  <data name="UseAwaitInstead" xml:space="preserve">
    <value>Použijte raději await.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_MessageFormat" xml:space="preserve">
    <value>Synchronní čekání na položky typu task nebo awaiter může způsobit vzájemné zablokování. Místo toho použijte await nebo JoinableTaskFactory.Run.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_Title" xml:space="preserve">
    <value>Vyhněte se problematickým synchronním čekáním</value>
  </data>
  <data name="VSTHRD010_MessageFormat" xml:space="preserve">
    <value>Službu Visual Studio {0} je třeba používat explicitně v hlavním vlákně.
Nejprve zavolejte ThreadHelper.ThrowIfNotOnUIThread() nebo počkejte na JoinableTaskFactory.SwitchToMainThreadAsync().</value>
    <comment>{0} is a type name and {1} is the name of a method that throws if not called from the main thread.</comment>
  </data>
  <data name="VSTHRD010_Title" xml:space="preserve">
    <value>Použití služeb VS z vlákna uživatelského rozhraní</value>
  </data>
  <data name="VSTHRD100_MessageFormat" xml:space="preserve">
    <value>Nepoužívejte metody async void, protože veškeré výjimky neošetřené metodou způsobí selhání procesu.</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD100_Title" xml:space="preserve">
    <value>Vyhněte se použití metod async void</value>
    <comment>"async void" is a pair of C# keywords. Do not translate them.</comment>
  </data>
  <data name="VSTHRD101_MessageFormat" xml:space="preserve">
    <value>U typu delegáta, který vrací hodnotu void, se vyhněte použití asynchronního výrazu lambda, protože veškeré výjimky neošetřené delegátem způsobí selhání procesu.</value>
    <comment>"void" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="VSTHRD101_Title" xml:space="preserve">
    <value>Vyhněte se použití nepodporovaných asynchronních delegátů</value>
  </data>
  <data name="VSTHRD106_MessageFormat" xml:space="preserve">
    <value>Delegáti AsyncEventHandler se musí volat prostřednictvím metody rozšíření TplExtensions.InvokeAsync() definované v sestavení Microsoft.VisualStudio.Threading.</value>
  </data>
  <data name="VSTHRD106_Title" xml:space="preserve">
    <value>Použití InvokeAsync k vyvolání asynchronních událostí</value>
  </data>
  <data name="VSTHRD003_MessageFormat" xml:space="preserve">
    <value>Volání operátoru await u položky typu Task uvnitř JoinableTaskFactory.Run v případě, že je úloha inicializovaná mimo delegáta, může způsobit potenciální vzájemná blokování.
Tomuto problému můžete předejít tak, že zajistíte inicializaci úlohy v rámci delegáta nebo místo položky typu Task použijete JoinableTask.</value>
  </data>
  <data name="VSTHRD003_Title" xml:space="preserve">
    <value>Vyhněte se použití operátoru await u nespojitelných úloh v kontextech spojení</value>
  </data>
  <data name="VSTHRD011_MessageFormat" xml:space="preserve">
    <value>Lazy&lt;Task&lt;T&gt;&gt;.Value může způsobit vzájemné blokování.
Použijte raději AsyncLazy&lt;T&gt;.</value>
  </data>
  <data name="VSTHRD011_Title" xml:space="preserve">
    <value>Vyhněte se použití Lazy&lt;T&gt;, kde T označuje Task&lt;T2&gt;</value>
  </data>
  <data name="VSTHRD103_MessageFormat" xml:space="preserve">
    <value>{0} provádí synchronní blokování. Místo toho použijte await {1}.</value>
  </data>
  <data name="VSTHRD103_MessageFormat_UseAwaitInstead" xml:space="preserve">
    <value>{0} provádí synchronní blokování. Místo toho použijte await.</value>
  </data>
  <data name="VSTHRD103_Title" xml:space="preserve">
    <value>Volání asynchronních metod v asynchronní metodě</value>
  </data>
  <data name="VSTHRD102_MessageFormat" xml:space="preserve">
    <value>Omezte použití volání metod, které provádí synchronní blokování, například JoinableTaskFactory.Run nebo Task.Result, na veřejné členy vstupního bodu, kde musíte být synchronní. Použití těchto metod pro interní členy zbytečně přidává synchronní rámce mezi asynchronní rámce, což vede k vyčerpání fondu vláken.</value>
  </data>
  <data name="VSTHRD102_Title" xml:space="preserve">
    <value>Asynchronní implementace interní logiky</value>
  </data>
  <data name="VSTHRD200_CodeFix_Title" xml:space="preserve">
    <value>Přejmenování na {0}</value>
    <comment>{0} is a method name.</comment>
  </data>
  <data name="VSTHRD200_MessageFormat" xml:space="preserve">
    <value>Příponu Async použijte v názvech metod, které vrací Task.</value>
  </data>
  <data name="VSTHRD200_Title" xml:space="preserve">
    <value>Použití přípony Async pro asynchronní metody</value>
  </data>
  <data name="VSTHRD100_CodeFix_Title" xml:space="preserve">
    <value>Změňte návratový typ na Task.</value>
    <comment>Task is a type name and should not be translated.</comment>
  </data>
  <data name="VSTHRD105_MessageFormat" xml:space="preserve">
    <value>Nepoužívejte přetížení metod, která předpokládají TaskScheduler.Current. Použijte přetížení, které akceptuje TaskScheduler a explicitně zadejte TaskScheduler.Default (případně jakoukoli jinou vlastnost).</value>
  </data>
  <data name="VSTHRD105_Title" xml:space="preserve">
    <value>Vyhněte se přetížením metod, která předpokládají TaskScheduler.Current</value>
  </data>
  <data name="VSTHRD012_MessageFormat" xml:space="preserve">
    <value>Zadejte instanci JoinableTaskFactory v tomto volání (nebo v jiném přetížení), aby se předešlo zablokováním s hlavním vláknem.</value>
  </data>
  <data name="VSTHRD012_Title" xml:space="preserve">
    <value>Zadejte JoinableTaskFactory, kde je to povoleno</value>
  </data>
  <data name="VSTHRD104_MessageFormat" xml:space="preserve">
    <value>Nabízejte asynchronní verzi této metody, která se synchronně neblokuje. Pak zjednodušte tuto metodu tak, aby volala tuto asynchronní metodu v delegátovi JoinableTaskFactory.Run.</value>
  </data>
  <data name="VSTHRD104_Title" xml:space="preserve">
    <value>Nabízejte asynchronní metody</value>
  </data>
  <data name="VSTHRD001_MessageFormat" xml:space="preserve">
    <value>Počkejte, než se na vlákno uživatelského rozhraní přepne JoinableTaskFactory.SwitchToMainThreadAsync(), a ne rozhraní API, která se můžou zablokovat nebo vyžadovat zadání priority.</value>
  </data>
  <data name="VSTHRD001_Title" xml:space="preserve">
    <value>Vyhněte se starším verzím rozhraní API pro přepínání vláken</value>
    <comment>thread switching APIs refers to Visual Studio SDK or .NET methods that can be used to switch threads, but are obsolete and should be avoided.</comment>
  </data>
  <data name="VSTHRD107_MessageFormat" xml:space="preserve">
    <value>Chybí operátor await ve výrazu using.</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD107_Title" xml:space="preserve">
    <value>Úloha await ve výrazu using</value>
    <comment>"await Task" is a C# compound term, and "using" is a C# keyword. These should not be translated.</comment>
  </data>
  <data name="VSTHRD107_CodeFix_Title" xml:space="preserve">
    <value>Výraz using s operátorem await</value>
    <comment>"await" and "using" are C# keywords and should not be translated.</comment>
  </data>
  <data name="VSTHRD002_CodeFix_Await_Title" xml:space="preserve">
    <value>Použijte raději await.</value>
    <comment>"await" is a C# keyword and should not be translated.</comment>
  </data>
</root>